# ch5. 재귀

# ch5. 재귀

---

# 5-1. 재귀란?


> 💡 하나의 메서드 내에서 자기자신을 호출하여 반복적인 개념을 구현


## ➡️ 5-1-1. for문에서 벗어나기

반복문 만으로 해결되지 않은 문제일 경우 사용

ex) 배열 arr에서 n개의 원소를 조합하는 문제일 경우 반복문을 작성할 수 없어서 다른 방식으로 구현해야함

## ➡️ 5-1-2. 재귀의 최대범위와 한계점

- 재귀호출은 반복 작업을 구현하여 재귀 호출 횟수가 시간 복잡도에 직접적으로 영향을 끼침
- 재귀호출 구현 시 재귀호출이 얼마나 수행되는지 확인해야함
- 또 한번 호출했을 때 어떤 작업을 해야하는지 따져야함
- 재귀 호출을 하면 메서드에서 사용할 변수들이 메모리에 추가 할당
  -  이렇게 메모리가 할당된 변수들은 해당 재귀 호출이 종료되었을때 자동으로 할당이 해제
  -  만약 제귀호출이 종료되지 않고 너무 깊게 들어가면 메모리를 모두 할당해서 StackOverFlowError가 발생
  - ⇒ 재귀 호출의 깊이를 안전하게  10,000 이하, 아무리 많아도 20,000이하로 유지시켜야함

---

# 5-2. 재귀 정의하기

<aside>
✏️ 예시 문제
0이상의 두 정수 n,m이 주어졌을 때 $n^m$을 구하여라.

</aside>

## 5-2-1. 상태 정의하기

- **부분 문제** : 각각 하나의 명확한 문제를 나타내며, 하나의 답을 낼 수 있어야함
- **상태** : 답을 결정하는 변수들

➡️ 부분 문제는 하나의 상태에 대한 답을 찾는 문제로 상태를 정의해야함


> ✏️ 위에서 제시된 문제에서 상태는 ***(n, m)***



> 💡 여기서 상태를 정의해도 풀기 어려운 문제들도 있음
> <aside>이럴 때는 부분 문제의 답을 이용하여 제시된 문제를 답을 유도할 수 있게 상태를 정의</aside>



## 5-2-2. 종료 조건

부분 문제를 생성하다보면 언제가는 종료해야함

상태는 재귀가 진행할 수록 점점 작아져, 이어지는 부분 문제 없이 답이 나와야함

- **종료조건** : 상태를 검사하여 답을 반환할 수 있게 하는 조건
- **상태가 작아진다** : 종료 조건에 도달할 수 있도록 부분 문제로 상태가 변해가는 것


>✏️ 예시에서 가장작은 상태는 계산할 필요 없이 상태만으로 답이 정해짐
> <aside> → (n ,0) = 1 </aside> 
> <aside>→ (0, m) =1</aside> 
> <aside>→ (1, m) = 1 </aside> 
> ➡️ n에 어떤 값이 들어 오든 m값이 0이면 1이 됨



## 5-2-3. 점화식

- **점화식** : 부분 문제는 같은 규칙으로 더 작은 부분 문제로, 더 작은 상태로 정의 되어야함. 그래서 이렇게 상태를 전이시키는 규칙을 점화식이라고 함

<aside>
✏️ $n^m = n \times n^{m-1} = n \times (n, m-1)$ 의 점화식을 세울 수 있음
이 식에서 상태가 전이 될수록 m의 값의 줄어들어 0에 도달 하고, 종료조건에 따라 재귀가 종료됨

</aside>

---

# 5-3. 코드 작성하기

## 5-3-1. 코드 변환하기


> ✏️ 예시 문제
> ### 1. 재귀 정의
> | 상태 | $$(n,m): n^m$$      |                  
> |----------------------------------------|----------------|
> | 종료조건 | (n, 0) = 1<br>(0, m) = 1<br>(1, m) = 1 |
> | 점화식 | $$(n, m) = n * (n, m-1)$$              |
> 
> ### 2. 부분 문제 나타내기
> 
> - 부분 문제는 하나의 메서드가 담당
> 
> ```java
> // 1.상태변수는 메서드의 입력부에 들어감
> private int power(int n, int m) {
> 	//3. 종료 조건 작성
> }
> ```
> 
> ### 3. 종료 조건 작성하기
> 
> ```java
> // 1.상태변수는 메서드의 입력부에 들어감
> private int power(int n, int m) {
> 	//3. 종료 조건 작성
> 	if(m == 0) return 1;
> 	if(n == 1) return 1;
> 	if(n == 0) return 1;
> }
> ```
> 
> ### 4. 점화식 구현
> 
> ```java
> // 1.상태변수는 메서드의 입력부에 들어감
> private int power(int n, int m) {
> 	//3. 종료 조건 작성
> 	if(m == 0) return 1;
> 	if(n == 1) return 1;
> 	if(n == 0) return 1;
> 
> 	//4. 점화식 구현
> 	return n*power(n,m-1);
> }
> ```


***
> ### 참고 문서
> [취업과 이직을 위한 프로그래머스 코딩 테스트 문제 풀이 전략: 자바 편](https://product.kyobobook.co.kr/detail/S000200928002)